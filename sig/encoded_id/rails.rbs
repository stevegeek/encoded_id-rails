module EncodedId
  module Rails
    VERSION: ::String

    class Coder
      def initialize: (salt: ::String, id_length: ::Integer, character_group_size: ::Integer, separator: ::String, alphabet: ::EncodedId::Alphabet) -> void
      def encode: (::Integer | ::Array[::Integer]) -> String
      def decode: (::String) -> (nil | ::Array[::Integer])

      @salt: ::String
      @id_length: ::Integer
      @character_group_size: ::Integer
      @separator: ::String
      @alphabet: ::EncodedId::Alphabet

      private

      def coder: -> ::EncodedId::ReversibleId
    end

    class Configuration
      attr_accessor salt: ::String
      attr_accessor group_separator: ::String
      attr_accessor character_group_size: ::Integer
      attr_accessor alphabet: ::EncodedId::Alphabet
      attr_accessor id_length: ::Integer
      attr_accessor slugged_id_separator: ::String

      def initialize: () -> void
    end

    class Salt
      def initialize: (untyped klass, ::String salt) -> void

      @klass: untyped
      @salt: ::String

      def generate!: -> ::String
    end

    class SluggedId
      def initialize: (untyped from_object, ?name_method: ::Symbol, ?id_method: ::Symbol, ?separator: ::String)-> void

      @from_object: untyped
      @name_method: ::Symbol
      @id_method: ::Symbol
      @separator: ::String

      def slugged_id: -> ::String
    end

    class SluggedIdParser
      def initialize: (::String slugged_id, ?separator: ::String) -> void

      attr_reader slug: (nil | ::String)
      attr_reader id: (nil | ::String)
    end

    attr_reader self.configuration: Configuration

    def self.configure: () { (Configuration config) -> void } -> void

    module WithEncodedId
      module ClassMethods
        def find_by_encoded_id: (::String slugged_encoded_id, ?with_id: ::Symbol?) -> (nil | untyped)
        def find_by_encoded_id!: (::String slugged_encoded_id, ?with_id: ::Symbol?) -> untyped
        def where_encoded_id: (::String slugged_encoded_id) -> untyped
        def encode_encoded_id: (untyped id, ?::Hash[::Symbol, untyped] options) -> ::String
        def decode_encoded_id: (::String slugged_encoded_id, ?::Hash[::Symbol, untyped] options) -> (nil | ::Array[::Integer])
        def encoded_id_salt: () -> ::String
        def encoded_id_parser: (::String slugged_encoded_id) -> ::EncodedId::Rails::SluggedIdParser
        def encoded_id_coder: (?::Hash[::Symbol, untyped] options) -> ::EncodedId::Rails::Coder

        # FIXME: Methods defined on AR, how to tell steep that this will be composed with AR?
        def where: (*untyped) -> untyped
        def find: (*untyped) -> (nil | untyped)
        def find!: (*untyped) -> untyped
        def find_by: (*untyped) -> (nil | untyped)
        def find_by!: (*untyped) -> untyped
      end

      # FIXME: steep doesnt understand that methods defined in ClassMethods will be added to the class, hence
      # the duplication here
      def self.find_by_encoded_id: (::String slugged_encoded_id, ?with_id: ::Symbol?) -> (nil | untyped)
      def self.find_by_encoded_id!: (::String slugged_encoded_id, ?with_id: ::Symbol?) -> untyped
      def self.where_encoded_id: (::String slugged_encoded_id) -> untyped
      def self.encode_encoded_id: (untyped id, ?::Hash[::Symbol, untyped] options) -> ::String
      def self.decode_encoded_id: (::String slugged_encoded_id, ?::Hash[::Symbol, untyped] options) -> (nil | ::Array[::Integer])
      def self.encoded_id_salt: () -> ::String
      def self.encoded_id_parser: (::String slugged_encoded_id) -> ::EncodedId::Rails::SluggedIdParser
      def self.encoded_id_coder: (?::Hash[::Symbol, untyped] options) -> ::EncodedId::Rails::Coder

      @encoded_id: ::String
      @slugged_encoded_id: ::String

      def encoded_id: () -> untyped
      def slugged_encoded_id: (?with: ::Symbol) -> untyped
      def slug: () -> untyped

      # FIXME: To make type check happy, but may not exist!
      # We call if respond_to? but type checker doesn't know that
      def name: () -> ::String
      def id: () -> ::String
    end
  end
end
